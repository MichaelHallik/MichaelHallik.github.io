---
comments_id: 1
tags: testposttext

---

Introduction.

Creating a virtual Python environment for your test automation project can be beneficial for many reasons. Among those reasons are:

1. Avoiding dependency hell: a project may contain dependencies to specific versions of third party libraries. This may conflict with required dependencies within one or more other projects, for instance those that might not only require the same Python version, but also diverget versions of the same third-party libraries. Good luck with manageing that!
2. Keeping your global/base Python installation clean: you won't have to clutter your site-packages and Scripts folders when installing third-party libraries and tools for various projects.
3. Being able to easily share a specific Python environment. For instance, in order to facilitate that every contributing team member uses the same Python version and tool stack.
4. Being able to quickly recreating/restoring your environment in case of problems related to that environment.

As is usually the case with Python, the task of creating and managing virtual environments is nothing but a breeze.

But what exactly is a virtual environment?

Well, you might look at it as a self-contained, isolated Python installation that, as such, is independent from any global/system Python installations (and their configurations) as well as from any other virtual Python environments (and their configurations).

Creating a virtual environment creates, foremost, a small directory structure. Depending on the tool, there are slight variations in these structures. However, regardless the tool, all virt envs basically consist of the following three fundamental components:

1. A Python excutable (with a version that you specified).

This might be a copy of the system executable or a so-called symlink.

2. The Python \Scripts folder (\bin on Unix/Linux).

This folder is mainly used by third-party packages (that are installed in \Lib\site-packages) to store scripts that are associated with them. As this folder (together with the root installation folder) is inserted into the PATH operating system variable (provided you chose that option during installation), you can run these scripts from the command line. For instance, when you invoke pip install <package_name> from the command line, the pip.exe script is called which acts as a wrapper for the pip module in \Lib\site-packages.

3. The Python \Lib\site-packages folder.

For third-party libraries/packages.

2) Decide on a tool (set).

First we need to decide on our tool set for creating and managing virtual Python environments. There are quite a few candidates. For instance:

- the venv mpdule, that is Python comes shipped with the venv module. However

2) Install one or more Python versions.

When creating virtual environments, you might have the need to be able todevelop, run and test code against multiple Python versions. Maybe you need or want to explicietly support multiple Python versions. Maybe your project directly or indirectly depends on a specific, older Python version, while others do not.

With 

1. Install one or more python versions.
2. Install the 
3 Install virtual env, e.g. in the most recent Py version installed (think PATH!).
- install virtualenvwrapper-win.
- Optionally: Set de WORK_HOME dir. This is a default dir for virt envs (when creating one, you don't have to specify a path, merely the name).
- Create a virt env (this will also activate the env; this means that the current command line session will have the relevant Py version on it's path)
(- Activate the env)
- install third-party libraries (site-packages), in our case: rf, etc.
- re-use the env in/with PyCharm.
