---
comments_id: 1
tags: testposttext

---

<h1> Introduction. </h1>

Creating a virtual Python environment for your test automation project can be beneficial for many reasons. Among those reasons are:

1. Avoiding dependency hell: a project may contain dependencies to specific versions of third party libraries. This may conflict with required dependencies within one or more other projects, for instance those that might not only require the same Python version, but also diverget versions of the same third-party libraries. Good luck with manageing that!
2. Keeping your global/base Python installation clean: you won't have to clutter your site-packages and Scripts folders when installing third-party libraries and tools for various projects.
3. Being able to easily share a specific Python environment. For instance, in order to facilitate that every contributing team member uses the same Python version and tool stack.
4. Being able to quickly recreating/restoring your environment in case of problems related to that environment.

As is usually the case with Python, the task of creating and managing virtual environments is nothing but a breeze.

<h1> But what exactly is a virtual environment? </h1>

You can see it as a self-contained, isolated Python installation that, as such, is independent from any global/system Python installations (and their configurations) as well as from any other virtual Python environments (and their configurations).

Creating a virtual environment generates a (relatively small) directory structure. Depending on the tool and depending on the parameters you apply when creating the environment, there are some variations within this structure. However, regardless the tool, all virtual environments basically consist of the following three fundamental components:

1. A Python excutable (with a version that you specified).

This might be a copy of the system executable that you based your environment on or a so-called symlink to that system executable. Again, this will depend on the tool used and on the parameters you selected.

2. The Python \Scripts folder (\bin on Unix/Linux).

This folder is part of every regular Python installation and also of every virtual environment. It is used by third-party modules/packages (which themselves get installed into the \Lib\site-packages folder) to store scripts and executables that are associated with them. As this folder (together with the root installation folder) usually gets added to the operating system's PATH variable (provided you chose that option during installation or manually edited PATH afterwards), you can run these scripts and executables from the command line. For instance, when you invoke pip install robotframework from the command line, pip.exe in the Scripts folder is called, which acts as a wrapper for the pip module in \Lib\site-packages.

3. The Python \Lib\site-packages folder.

This folder is used for third-party libraries/packages that are installed. For instance, Robot Framework, RIDE and all installed RF test libraries will reside in this folder.

2) Decide on a tool (set).

First we need to decide on our tool set for creating and managing virtual Python environments. There are quite a few candidates. For instance:

- the venv mpdule, that is Python comes shipped with the venv module. However

2) Install one or more Python versions.

When creating virtual environments, you might have the need to be able todevelop, run and test code against multiple Python versions. Maybe you need or want to explicietly support multiple Python versions. Maybe your project directly or indirectly depends on a specific, older Python version, while others do not.

With 

1. Install one or more python versions.
2. Install the 
3 Install virtual env, e.g. in the most recent Py version installed (think PATH!).
- install virtualenvwrapper-win.
- Optionally: Set de WORK_HOME dir. This is a default dir for virt envs (when creating one, you don't have to specify a path, merely the name).
- Create a virt env (this will also activate the env; this means that the current command line session will have the relevant Py version on it's path)
(- Activate the env)
- install third-party libraries (site-packages), in our case: rf, etc.
- re-use the env in/with PyCharm.
